find_path returns 0 when it find the string "PATH" within the environment.

main:

Struct initialisation
	- A struct is initialised, with variables needed for the project.
	The struct contains process ids, integers for the fds and tubes, 
	char arrays for env_paths and cmd, and array of char arrays for the
	cmd_paths and cmd_args.

Infile
	- The file descriptor for the infile is stored in the struct, if an eror occurs
	this is written to std_err and 1 is returned.

Outfile
	- The file descriptor for the outfile is stored in the struct. If the outfile
	doesn't exist it is created, with permission 644 (creator has all permissions,
	others are read only). Otherwise it deletes content with O_TRUNC before writing.
	Again, if an eror occurs, this is written to std_err and 1 is returned.

Pipe:
	- A pipe is opened using pipe(). The fds that are generated by pipe() are stored
	in pipex.tube[], which is an array of 2 ints. pipex.tube[1] is the "write" side 
	and pipex.tube[0] is "read" side.

Env Paths:
	- The environment variable is then parsed to retrieve PATH. This is stored in 
	pipex.env_path. The PATH variable is then split into an array.


Child Processes:

	fork() is called to create the first child. 
	pid == 0 -> we are in the child process.

	First Child:
		- int dup2(int oldfd, int newfd); is used to redirect the process 
		output into the pipe to the second child.
		
		dup2(pipex.tube[1], 1) closes std_out (1) and opens the stream
		to pipex.tube[1]. This means the std_out is replaced by pipex.tube[1],
		so what would have been printed to std_out goes into pipex.tube[1].
		The same is then done, with std_in (0). It is replaced with the
		infile file descriptor.

		- close(pipex.tube[0]) is needed to replace the input from std_in 
		to infile.

		- once pipex.tube[0] is closed, dup2 is used to set the input to
		the infile.

		- ft_split() splits argv[2] (command + arguments) into pipex.cmd_args
		- get_cmd() retrieves pipex.cmd_args[0] which is the command name.
		
		If that doesn't exist, t_pipex pipex is freed, an error msg is sent
		and the process is exited.
		If it does, the first child process is replaced by by whatever the 
		command is, with its arguments. execve() receives the path, the args 
		(argv[0] is ignored here), and the envp variable.




		Schematic for file descriptors:

		First Child
		Initial state	->	dup2				->	close				->	dup2
		0		std_in	->	0	std_in			->	0	-				->	0	infile	
		1		std_out	->	1	tube[1]			->	1	tube[1]			->	1	tube[1]


		Second Child
		Initial state	->	dup2			->	close				->	dup2
		0		std_in	->	0	tube[0]		->	0	tube[0]			->	0	tube[0]	
		1		std_out	->	1	std_out		->	1	-				->	1	outfile




	fork() is called again to create second child process.

	Second Child:
		- Basically the same as the first child, except the pipe redirections
		are different.
	
	close_pipes() closes all open pipes

	waitpid() is used to wait for specific pids to terminate

	free_pip() frees 